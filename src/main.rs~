#[macro_use]
extern crate lazy_static;
use std::fs::File;
use std::io::{BufRead, BufReader};
use std::io::{BufWriter, Write};

const MAX_PROFILES: usize = 10000;

struct Date {
    y: u32,
    m: u8,
    d: u8,
}

//#[derive(Debug)]
struct Profile {
    id: i32,
    name: String,
    birthday:Date,
    home: String,
    comment: String,
}

//mod app_context {
    use std::sync::RwLock;

    lazy_static! {
        
         static ref Profile_data_store: RwLock<Vec<Profile>>
	     = RwLock::new(Vec::with_capacity(10000));

         static ref Profile_data_nitems: RwLock<i32> = RwLock::new(0);
    }
//}

fn main() {
    'l: loop{
        let line = {
	    let mut line = String::new();
	    std::io::stdin().read_line(&mut line).unwrap();
	    line.trim_end().to_owned()
	};
        parse_line(&line)
    }


}

fn parse_line(str: &String){
    let line = str.replace("\n", "\0").to_string();
    if line.starts_with("%") {
        let cmd = &line.chars().nth(1).unwrap();
	let mut param = String::new();
	if line.len() > 2 {
    	    param = line[3..].to_string();
	} 
        exec_command(*cmd, &param);
    } else {
	let mut profile_data_store = Profile_data_store.write().unwrap();
	let mut profile_data_nitems = Profile_data_nitems.write().unwrap();
	let p = new_profile(&line);
	profile_data_store.push(p);
	*profile_data_nitems += 1;
    }
}

fn new_profile (csv: &String) -> Profile{
    let ptr:Vec<&str> = csv.splitn(5, ',').collect();

    Profile {
        id : match ptr[0].parse() {
	    Ok(num) => num,
	    Err(_) => 0,
	    },
        name : ptr[1].to_string(),
        birthday : new_date(&ptr[2].to_string()),
        home : ptr[3].to_string(),
        comment : ptr[4].to_string(),
    }
}

fn new_date(str: &String) -> Date{
    let ptr:Vec<&str> = str.splitn(3, '-').collect();

    Date {
        y : ptr[0].parse().unwrap(),
        m : ptr[1].parse().unwrap(),
        d : ptr[2].parse().unwrap(),
    }
}

fn exec_command(cmd:char, param:&String){
    if cmd == 'Q' {
        cmd_quit();
    } else if cmd == 'C' {
        cmd_check();
    } else if cmd == 'P' {
        cmd_print(param);
    } else if cmd == 'R' {
        cmd_read(param);
    } else if cmd == 'W' {
       cmd_write(param);
    } else if cmd == 'F' {
        cmd_find(param);
//    } else if cmd == 'S' {
//        cmd_sort();
    } else {
	println!("Invailed command {}: ignored.\n", cmd);
    }
}

fn cmd_quit(){
    std::process::exit(1);
}

fn cmd_check(){
    let profile_data_nitems = Profile_data_nitems.read().unwrap();
    println!("{} profile(s)\n", profile_data_nitems);
}

fn cmd_print(param: &String){
    let mut i:usize;
    let mut start = 0;
    let nitems = param.parse().unwrap();
    let profile = Profile_data_nitems.read().unwrap();
    let mut end = *profile;
    
    if nitems > 0 {
        end = min(nitems, *profile);
    }
    if nitems < 0 {
        let a = end + nitems;
        start = max(a, 0);
    }

    i = start as usize;

    while i < end as usize {
        print_profile(i);
	println!("\n");
	i += 1;
    }
}

fn min(a:i32, b:i32) -> i32{
    if a < b {
        return a;
    }
    b
}
fn max(a:i32, b: i32) -> i32{
    if a > b {
        return a;
    }
    b
}

fn print_profile(i: usize){
    let vec = Profile_data_store.read().unwrap();
    
    println!("Id   : {}", vec[i].id);
    println!("Name : {}", vec[i].name);
    println!("Birth: {}", date_to_string(&vec[i].birthday));
    println!("Addr : {}", vec[i].home);
    println!("Com. : {}", vec[i].comment);
}

fn date_to_string(p:&Date) -> String{
    let s1 = p.y.to_string();
    let s2 = p.m.to_string();
    let s3 = p.d.to_string();

    let s = format!("{}-{}-{}", s1, s2, s3);
    s
}

fn cmd_read(filename: &String){
    let mut f = File::open(filename).unwrap();
    let reader = BufReader::new(f);
    
    for (index, line) in reader.lines().enumerate(){
        let line = line.unwrap();

        parse_line(&line);
    
    }
    println!("Read Success\n");
}

fn cmd_write(filename: &String){
    let mut f = File::create(filename).unwrap();
    let mut writer = BufWriter::new(f);
    let mut v = Profile_data_store.read().unwrap();
    for i in v.iter() {
        let contents = format!("{},{},{},{},{}\n",i.id, i.name, date_to_string(&i.birthday), i.home, i.comment);
        writer.write_all(contents.as_bytes()).unwrap();
    }
    println!("Write Success\n");
}

fn cmd_find(word: &String){
    let mut i:usize = 0;
    let profile = Profile_data_nitems.read().unwrap();
    let mut end = *profile as usize;

    while i < end {
        let vec = Profile_data_store.read().unwrap();

        if vec[i].id.to_string().starts_with(word) ||
	vec[i].name.starts_with(word) ||
	date_to_string(&vec[i].birthday).starts_with(word) ||
        vec[i].home.starts_with(word) ||
        vec[i].comment.starts_with(word) {
            print_profile(i);
     	    println!("\n");
	}
	i += 1;
    }

}

//fn cmd_sort(column: i32){
//    match column {
//        1 => 
//}

